/* tslint:disable */
/* eslint-disable */
/**
 * Prehakaton - API
 * XYXYXY 
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthenticationPayload
 */
export interface AuthenticationPayload {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPayload
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPayload
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChatModel
 */
export interface ChatModel {
    /**
     * 
     * @type {string}
     * @memberof ChatModel
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatModel
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface ChatResponse
 */
export interface ChatResponse {
    /**
     * 
     * @type {string}
     * @memberof ChatResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Prompt>}
     * @memberof ChatResponse
     */
    'prompts'?: Array<Prompt>;
    /**
     * 
     * @type {string}
     * @memberof ChatResponse
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatResponse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof CreateUser
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof CreateUser
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof CreateUser
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface Exception
 */
export interface Exception {
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface HaveCreationAndUpdate
 */
export interface HaveCreationAndUpdate {
    /**
     * 
     * @type {string}
     * @memberof HaveCreationAndUpdate
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof HaveCreationAndUpdate
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface HaveImageProperties
 */
export interface HaveImageProperties {
    /**
     * 
     * @type {string}
     * @memberof HaveImageProperties
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HaveImageProperties
     */
    'picture_is_implemented'?: boolean;
}
/**
 * 
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Notification
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'body'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'isRead'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Project
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ProjectCategory>}
     * @memberof Project
     */
    'categories'?: Array<ProjectCategory>;
    /**
     * 
     * @type {User}
     * @memberof Project
     */
    'investor'?: User;
    /**
     * 
     * @type {User}
     * @memberof Project
     */
    'technicalSolution'?: User;
    /**
     * 
     * @type {Array<ProjectSession>}
     * @memberof Project
     */
    'sessions'?: Array<ProjectSession>;
    /**
     * 
     * @type {StatusEnum}
     * @memberof Project
     */
    'status'?: StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'price'?: number;
    /**
     * 
     * @type {Location}
     * @memberof Project
     */
    'localisation'?: Location;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'start_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'end_datetime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    'need_investor'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    'need_technical_solution'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'like_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'view_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'star_medium'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    'picture_is_implemented'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface ProjectCategory
 */
export interface ProjectCategory {
    /**
     * Nom de la categorie
     * @type {string}
     * @memberof ProjectCategory
     */
    'name'?: string;
    /**
     * Détails supplémentaires concernant la categorie
     * @type {string}
     * @memberof ProjectCategory
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ProjectSession
 */
export interface ProjectSession {
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'id'?: string;
    /**
     * 
     * @type {Project}
     * @memberof ProjectSession
     */
    'project'?: Project;
    /**
     * 
     * @type {Location}
     * @memberof ProjectSession
     */
    'location'?: Location;
    /**
     * 
     * @type {StatusSessionEnum}
     * @memberof ProjectSession
     */
    'status'?: StatusSessionEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'end_datetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectSession
     */
    'like_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectSession
     */
    'view_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectSession
     */
    'star_medium'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSession
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @interface Prompt
 */
export interface Prompt {
    /**
     * 
     * @type {string}
     * @memberof Prompt
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Prompt
     */
    'prompt_category'?: string;
    /**
     * 
     * @type {string}
     * @memberof Prompt
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof Prompt
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Prompt
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Reaction
 */
export interface Reaction {
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'id'?: string;
    /**
     * 
     * @type {ReactionType}
     * @memberof Reaction
     */
    'likeReaction'?: ReactionType;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'subject_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Reaction
     */
    'vision'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Reaction
     */
    'StarsNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReactionType = {
    Like: 'LIKE',
    Dislike: 'DISLIKE'
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];


/**
 * 
 * @export
 * @interface ReactionsProperties
 */
export interface ReactionsProperties {
    /**
     * 
     * @type {number}
     * @memberof ReactionsProperties
     */
    'like_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReactionsProperties
     */
    'view_number'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReactionsProperties
     */
    'star_medium'?: number;
}
/**
 * 
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    TechnicalSolution: 'TECHNICAL_SOLUTION',
    ProjectOwner: 'PROJECT_OWNER',
    Investor: 'INVESTOR',
    Manager: 'MANAGER'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @enum {string}
 */

export const Sex = {
    M: 'M',
    F: 'F',
    Other: 'OTHER'
} as const;

export type Sex = typeof Sex[keyof typeof Sex];


/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof SignUp
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof SignUp
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof SignUp
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface Signalisation
 */
export interface Signalisation {
    /**
     * 
     * @type {string}
     * @memberof Signalisation
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Signalisation
     */
    'user'?: User;
    /**
     * Raison de la signalisation
     * @type {string}
     * @memberof Signalisation
     */
    'reason'?: string;
    /**
     * Détails supplémentaires concernant la signalisation
     * @type {string}
     * @memberof Signalisation
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof Signalisation
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Signalisation
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatusEnum = {
    Planning: 'PLANNING',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const StatusSessionEnum = {
    NotStarting: 'NOT_STARTING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED'
} as const;

export type StatusSessionEnum = typeof StatusSessionEnum[keyof typeof StatusSessionEnum];


/**
 * 
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'photo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_banner_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'entrance_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof User
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof User
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface UserPicture
 */
export interface UserPicture {
    /**
     * 
     * @type {string}
     * @memberof UserPicture
     */
    'user_id'?: string;
    /**
     * 
     * @type {UserPictureType}
     * @memberof UserPicture
     */
    'type'?: UserPictureType;
    /**
     * 
     * @type {string}
     * @memberof UserPicture
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserPictureType = {
    Banner: 'BANNER',
    Profile: 'PROFILE'
} as const;

export type UserPictureType = typeof UserPictureType[keyof typeof UserPictureType];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Enabled: 'ENABLED',
    Banished: 'BANISHED'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 
 * @export
 * @interface Whoami
 */
export interface Whoami {
    /**
     * 
     * @type {User}
     * @memberof Whoami
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Whoami
     */
    'bearer'?: string;
}

/**
 * ChatbotApi - axios parameter creator
 * @export
 */
export const ChatbotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotInformation: async (id: string, prompt: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChatbotInformation', 'id', id)
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('getChatbotInformation', 'prompt', prompt)
            const localVarPath = `/users/{id}/chat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} tsid 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotTechnicalInformation: async (id: string, tsid: string, prompt: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChatbotTechnicalInformation', 'id', id)
            // verify required parameter 'tsid' is not null or undefined
            assertParamExists('getChatbotTechnicalInformation', 'tsid', tsid)
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('getChatbotTechnicalInformation', 'prompt', prompt)
            const localVarPath = `/users/{id}/technical-solution/{tsid}/chat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tsid"}}`, encodeURIComponent(String(tsid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add information from in chatbot.
         * @param {string} tsid 
         * @param {Prompt} prompt User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChatbotTechnicalInformation: async (tsid: string, prompt: Prompt, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tsid' is not null or undefined
            assertParamExists('putChatbotTechnicalInformation', 'tsid', tsid)
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('putChatbotTechnicalInformation', 'prompt', prompt)
            const localVarPath = `/technical-solution/{tsid}/prompt`
                .replace(`{${"tsid"}}`, encodeURIComponent(String(tsid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prompt, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotApi - functional programming interface
 * @export
 */
export const ChatbotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbotInformation(id: string, prompt: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbotInformation(id, prompt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.getChatbotInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} tsid 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbotTechnicalInformation(id: string, tsid: string, prompt: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbotTechnicalInformation(id, tsid, prompt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.getChatbotTechnicalInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add information from in chatbot.
         * @param {string} tsid 
         * @param {Prompt} prompt User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChatbotTechnicalInformation(tsid: string, prompt: Prompt, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Prompt>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChatbotTechnicalInformation(tsid, prompt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.putChatbotTechnicalInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotApi - factory interface
 * @export
 */
export const ChatbotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotApiFp(configuration)
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotInformation(id: string, prompt: string, options?: any): AxiosPromise<Array<ChatResponse>> {
            return localVarFp.getChatbotInformation(id, prompt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} tsid 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotTechnicalInformation(id: string, tsid: string, prompt: string, options?: any): AxiosPromise<Array<ChatResponse>> {
            return localVarFp.getChatbotTechnicalInformation(id, tsid, prompt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add information from in chatbot.
         * @param {string} tsid 
         * @param {Prompt} prompt User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChatbotTechnicalInformation(tsid: string, prompt: Prompt, options?: any): AxiosPromise<Array<Prompt>> {
            return localVarFp.putChatbotTechnicalInformation(tsid, prompt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatbotApi - object-oriented interface
 * @export
 * @class ChatbotApi
 * @extends {BaseAPI}
 */
export class ChatbotApi extends BaseAPI {
    /**
     * 
     * @summary Obtain information from the chatbot.
     * @param {string} id 
     * @param {string} prompt The question to ask the chatbot about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getChatbotInformation(id: string, prompt: string, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getChatbotInformation(id, prompt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtain information from the chatbot.
     * @param {string} id 
     * @param {string} tsid 
     * @param {string} prompt The question to ask the chatbot about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getChatbotTechnicalInformation(id: string, tsid: string, prompt: string, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getChatbotTechnicalInformation(id, tsid, prompt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add information from in chatbot.
     * @param {string} tsid 
     * @param {Prompt} prompt User to crupdate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public putChatbotTechnicalInformation(tsid: string, prompt: Prompt, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).putChatbotTechnicalInformation(tsid, prompt, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary ping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationingApi - axios parameter creator
 * @export
 */
export const LocationingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crupdate location by identifier.
         * @param {string} pid 
         * @param {Location} location Location to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateLocationById: async (pid: string, location: Location, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateLocationById', 'pid', pid)
            // verify required parameter 'location' is not null or undefined
            assertParamExists('crupdateLocationById', 'location', location)
            const localVarPath = `/locations/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get location by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getLocationById', 'pid', pid)
            const localVarPath = `/locations/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all locations.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations: async (page: number, pageSize: number, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getLocations', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getLocations', 'pageSize', pageSize)
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationingApi - functional programming interface
 * @export
 */
export const LocationingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crupdate location by identifier.
         * @param {string} pid 
         * @param {Location} location Location to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateLocationById(pid: string, location: Location, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateLocationById(pid, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationingApi.crupdateLocationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get location by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationingApi.getLocationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all locations.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocations(page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Location>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocations(page, pageSize, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationingApi.getLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationingApi - factory interface
 * @export
 */
export const LocationingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationingApiFp(configuration)
    return {
        /**
         * 
         * @summary Crupdate location by identifier.
         * @param {string} pid 
         * @param {Location} location Location to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateLocationById(pid: string, location: Location, options?: any): AxiosPromise<Location> {
            return localVarFp.crupdateLocationById(pid, location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get location by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationById(pid: string, options?: any): AxiosPromise<Location> {
            return localVarFp.getLocationById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all locations.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations(page: number, pageSize: number, isSuggest?: boolean, options?: any): AxiosPromise<Array<Location>> {
            return localVarFp.getLocations(page, pageSize, isSuggest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationingApi - object-oriented interface
 * @export
 * @class LocationingApi
 * @extends {BaseAPI}
 */
export class LocationingApi extends BaseAPI {
    /**
     * 
     * @summary Crupdate location by identifier.
     * @param {string} pid 
     * @param {Location} location Location to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationingApi
     */
    public crupdateLocationById(pid: string, location: Location, options?: RawAxiosRequestConfig) {
        return LocationingApiFp(this.configuration).crupdateLocationById(pid, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get location by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationingApi
     */
    public getLocationById(pid: string, options?: RawAxiosRequestConfig) {
        return LocationingApiFp(this.configuration).getLocationById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all locations.
     * @param {number} page 
     * @param {number} pageSize 
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationingApi
     */
    public getLocations(page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return LocationingApiFp(this.configuration).getLocations(page, pageSize, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectSessioningApi - axios parameter creator
 * @export
 */
export const ProjectSessioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crupdate projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {ProjectSession} projectSession ProjectSession to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateProjectSessionById: async (xid: string, pid: string, projectSession: ProjectSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('crupdateProjectSessionById', 'xid', xid)
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateProjectSessionById', 'pid', pid)
            // verify required parameter 'projectSession' is not null or undefined
            assertParamExists('crupdateProjectSessionById', 'projectSession', projectSession)
            const localVarPath = `/projects/{xid}/project-sessions/{pid}`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)))
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSessionById: async (xid: string, pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getProjectSessionById', 'xid', xid)
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getProjectSessionById', 'pid', pid)
            const localVarPath = `/projects/{xid}/project-sessions/{pid}`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)))
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} xid ID du cours
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSessions: async (xid: string, page: number, pageSize: number, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getProjectSessions', 'xid', xid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getProjectSessions', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getProjectSessions', 'pageSize', pageSize)
            const localVarPath = `/projects/{xid}/project-sessions`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} id ID de l\&#39;utilisateur
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectSessions: async (id: string, page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserProjectSessions', 'id', id)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getUserProjectSessions', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getUserProjectSessions', 'pageSize', pageSize)
            const localVarPath = `/users/{id}/project-sessions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSessioningApi - functional programming interface
 * @export
 */
export const ProjectSessioningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSessioningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crupdate projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {ProjectSession} projectSession ProjectSession to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateProjectSessionById(xid: string, pid: string, projectSession: ProjectSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateProjectSessionById(xid, pid, projectSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSessioningApi.crupdateProjectSessionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSessionById(xid: string, pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSessionById(xid, pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSessioningApi.getProjectSessionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} xid ID du cours
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSessions(xid: string, page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSessions(xid, page, pageSize, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSessioningApi.getProjectSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} id ID de l\&#39;utilisateur
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProjectSessions(id: string, page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProjectSessions(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectSessioningApi.getUserProjectSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectSessioningApi - factory interface
 * @export
 */
export const ProjectSessioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSessioningApiFp(configuration)
    return {
        /**
         * 
         * @summary Crupdate projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {ProjectSession} projectSession ProjectSession to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateProjectSessionById(xid: string, pid: string, projectSession: ProjectSession, options?: any): AxiosPromise<ProjectSession> {
            return localVarFp.crupdateProjectSessionById(xid, pid, projectSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get projectSession by identifier.
         * @param {string} xid ID du cours
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSessionById(xid: string, pid: string, options?: any): AxiosPromise<ProjectSession> {
            return localVarFp.getProjectSessionById(xid, pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} xid ID du cours
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSessions(xid: string, page: number, pageSize: number, isSuggest?: boolean, options?: any): AxiosPromise<Array<ProjectSession>> {
            return localVarFp.getProjectSessions(xid, page, pageSize, isSuggest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projectSessions.
         * @param {string} id ID de l\&#39;utilisateur
         * @param {number} page 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectSessions(id: string, page: number, pageSize: number, options?: any): AxiosPromise<Array<ProjectSession>> {
            return localVarFp.getUserProjectSessions(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSessioningApi - object-oriented interface
 * @export
 * @class ProjectSessioningApi
 * @extends {BaseAPI}
 */
export class ProjectSessioningApi extends BaseAPI {
    /**
     * 
     * @summary Crupdate projectSession by identifier.
     * @param {string} xid ID du cours
     * @param {string} pid 
     * @param {ProjectSession} projectSession ProjectSession to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSessioningApi
     */
    public crupdateProjectSessionById(xid: string, pid: string, projectSession: ProjectSession, options?: RawAxiosRequestConfig) {
        return ProjectSessioningApiFp(this.configuration).crupdateProjectSessionById(xid, pid, projectSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get projectSession by identifier.
     * @param {string} xid ID du cours
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSessioningApi
     */
    public getProjectSessionById(xid: string, pid: string, options?: RawAxiosRequestConfig) {
        return ProjectSessioningApiFp(this.configuration).getProjectSessionById(xid, pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projectSessions.
     * @param {string} xid ID du cours
     * @param {number} page 
     * @param {number} pageSize 
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSessioningApi
     */
    public getProjectSessions(xid: string, page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return ProjectSessioningApiFp(this.configuration).getProjectSessions(xid, page, pageSize, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projectSessions.
     * @param {string} id ID de l\&#39;utilisateur
     * @param {number} page 
     * @param {number} pageSize 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSessioningApi
     */
    public getUserProjectSessions(id: string, page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return ProjectSessioningApiFp(this.configuration).getUserProjectSessions(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectingApi - axios parameter creator
 * @export
 */
export const ProjectingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crupdate project by identifier.
         * @param {string} pid 
         * @param {Project} project Project to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateProjectById: async (pid: string, project: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateProjectById', 'pid', pid)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('crupdateProjectById', 'project', project)
            const localVarPath = `/projects/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reacte an projects.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionProjects: async (uid: string, xid: string, reaction: Reaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('crupdateReactionProjects', 'uid', uid)
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('crupdateReactionProjects', 'xid', xid)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('crupdateReactionProjects', 'reaction', reaction)
            const localVarPath = `/users/{uid}/projects/{xid}/react`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getProjectById', 'pid', pid)
            const localVarPath = `/projects/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all projects.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (page?: number, pageSize?: number, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all ReactionProjects.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionProjects: async (xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getReactionProjects', 'xid', xid)
            const localVarPath = `/projects/{xid}/react`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (haveLikeReaction !== undefined) {
                localVarQueryParameter['have_like_reaction'] = haveLikeReaction;
            }

            if (haveVision !== undefined) {
                localVarQueryParameter['have_vision'] = haveVision;
            }

            if (haveStarsNumber !== undefined) {
                localVarQueryParameter['have_stars_number'] = haveStarsNumber;
            }

            if (haveComment !== undefined) {
                localVarQueryParameter['have_comment'] = haveComment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit project picture
         * @param {string} xid 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProjectPicture: async (xid: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('putProjectPicture', 'xid', xid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putProjectPicture', 'body', body)
            const localVarPath = `/projects/{xid}/pictures`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectingApi - functional programming interface
 * @export
 */
export const ProjectingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crupdate project by identifier.
         * @param {string} pid 
         * @param {Project} project Project to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateProjectById(pid: string, project: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateProjectById(pid, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.crupdateProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reacte an projects.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateReactionProjects(uid: string, xid: string, reaction: Reaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateReactionProjects(uid, xid, reaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.crupdateReactionProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get project by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.getProjectById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all projects.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(page?: number, pageSize?: number, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(page, pageSize, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.getProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all ReactionProjects.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReactionProjects(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReactionProjects(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.getReactionProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Submit project picture
         * @param {string} xid 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProjectPicture(xid: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProjectPicture(xid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectingApi.putProjectPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectingApi - factory interface
 * @export
 */
export const ProjectingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectingApiFp(configuration)
    return {
        /**
         * 
         * @summary Crupdate project by identifier.
         * @param {string} pid 
         * @param {Project} project Project to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateProjectById(pid: string, project: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.crupdateProjectById(pid, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reacte an projects.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionProjects(uid: string, xid: string, reaction: Reaction, options?: any): AxiosPromise<Reaction> {
            return localVarFp.crupdateReactionProjects(uid, xid, reaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get project by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectById(pid: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProjectById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all projects.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(page?: number, pageSize?: number, isSuggest?: boolean, options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.getProjects(page, pageSize, isSuggest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all ReactionProjects.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionProjects(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.getReactionProjects(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit project picture
         * @param {string} xid 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProjectPicture(xid: string, body: File, options?: any): AxiosPromise<Project> {
            return localVarFp.putProjectPicture(xid, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectingApi - object-oriented interface
 * @export
 * @class ProjectingApi
 * @extends {BaseAPI}
 */
export class ProjectingApi extends BaseAPI {
    /**
     * 
     * @summary Crupdate project by identifier.
     * @param {string} pid 
     * @param {Project} project Project to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public crupdateProjectById(pid: string, project: Project, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).crupdateProjectById(pid, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reacte an projects.
     * @param {string} uid 
     * @param {string} xid 
     * @param {Reaction} reaction Reaction to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public crupdateReactionProjects(uid: string, xid: string, reaction: Reaction, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).crupdateReactionProjects(uid, xid, reaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get project by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public getProjectById(pid: string, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).getProjectById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all projects.
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public getProjects(page?: number, pageSize?: number, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).getProjects(page, pageSize, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all ReactionProjects.
     * @param {string} xid 
     * @param {string} [uid] 
     * @param {boolean} [haveLikeReaction] 
     * @param {boolean} [haveVision] 
     * @param {boolean} [haveStarsNumber] 
     * @param {boolean} [haveComment] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public getReactionProjects(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).getReactionProjects(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit project picture
     * @param {string} xid 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectingApi
     */
    public putProjectPicture(xid: string, body: File, options?: RawAxiosRequestConfig) {
        return ProjectingApiFp(this.configuration).putProjectPicture(xid, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (authenticationPayload: AuthenticationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationPayload' is not null or undefined
            assertParamExists('signIn', 'authenticationPayload', authenticationPayload)
            const localVarPath = `/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUp: SignUp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUp' is not null or undefined
            assertParamExists('signUp', 'signUp', signUp)
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(authenticationPayload: AuthenticationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(authenticationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUp: SignUp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.whoami']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(authenticationPayload: AuthenticationPayload, options?: any): AxiosPromise<Whoami> {
            return localVarFp.signIn(authenticationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUp: SignUp, options?: any): AxiosPromise<Whoami> {
            return localVarFp.signUp(signUp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<Whoami> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary Login user.
     * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public signIn(authenticationPayload: AuthenticationPayload, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).signIn(authenticationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up user
     * @param {SignUp} signUp Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public signUp(signUp: SignUp, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).signUp(signUp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public whoami(options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateUserById: async (id: string, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crupdateUserById', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('crupdateUserById', 'user', user)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Récupérer les notifications de l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserNotifications', 'id', id)
            const localVarPath = `/users/{id}/notification`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPicture: async (uid: string, type: UserPictureType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserPicture', 'uid', uid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getUserPicture', 'type', type)
            const localVarPath = `/users/{uid}/pictures`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Récupérer les cours suivis par l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {string} pid ID de l\&#39;projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribedProjects: async (id: string, pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserSubscribedProjects', 'id', id)
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getUserSubscribedProjects', 'pid', pid)
            const localVarPath = `/users/{id}/projects/{pid}/subscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page: number, pageSize: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getUsers', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getUsers', 'pageSize', pageSize)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPicture: async (uid: string, type: UserPictureType, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('putUserPicture', 'uid', uid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putUserPicture', 'type', type)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putUserPicture', 'body', body)
            const localVarPath = `/users/{uid}/pictures`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateUserById(id: string, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateUserById(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.crupdateUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Récupérer les notifications de l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPicture(uid: string, type: UserPictureType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPicture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPicture(uid, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Récupérer les cours suivis par l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {string} pid ID de l\&#39;projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSubscribedProjects(id: string, pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSubscribedProjects(id, pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserSubscribedProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page: number, pageSize: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(page, pageSize, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserPicture(uid: string, type: UserPictureType, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPicture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserPicture(uid, type, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.putUserPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateUserById(id: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.crupdateUserById(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Récupérer les notifications de l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(id: string, options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.getUserNotifications(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPicture(uid: string, type: UserPictureType, options?: any): AxiosPromise<UserPicture> {
            return localVarFp.getUserPicture(uid, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Récupérer les cours suivis par l\'utilisateur
         * @param {string} id ID de l\&#39;utilisateur
         * @param {string} pid ID de l\&#39;projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSubscribedProjects(id: string, pid: string, options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.getUserSubscribedProjects(id, pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page: number, pageSize: number, name?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(page, pageSize, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPicture(uid: string, type: UserPictureType, body: File, options?: any): AxiosPromise<UserPicture> {
            return localVarFp.putUserPicture(uid, type, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Crupdate user by identifier.
     * @param {string} id 
     * @param {User} user User to crupdate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public crupdateUserById(id: string, user: User, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).crupdateUserById(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by identifier.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Récupérer les notifications de l\'utilisateur
     * @param {string} id ID de l\&#39;utilisateur
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserNotifications(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserNotifications(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user picture of the type profile banner or profile picture
     * @param {string} uid 
     * @param {UserPictureType} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserPicture(uid: string, type: UserPictureType, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserPicture(uid, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Récupérer les cours suivis par l\'utilisateur
     * @param {string} id ID de l\&#39;utilisateur
     * @param {string} pid ID de l\&#39;projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSubscribedProjects(id: string, pid: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSubscribedProjects(id, pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users.
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [name] Filter user by first name or lastname or username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(page: number, pageSize: number, name?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(page, pageSize, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit user picture of the type profile banner or profile picture
     * @param {string} uid 
     * @param {UserPictureType} type 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserPicture(uid: string, type: UserPictureType, body: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserPicture(uid, type, body, options).then((request) => request(this.axios, this.basePath));
    }
}



