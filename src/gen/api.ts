/* tslint:disable */
/* eslint-disable */
/**
 * Example - API
 * XYXYXY 
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthenticationPayload
 */
export interface AuthenticationPayload {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPayload
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationPayload
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ChatResponse
 */
export interface ChatResponse {
    /**
     * 
     * @type {string}
     * @memberof ChatResponse
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatResponse
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof CreateUser
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof CreateUser
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof CreateUser
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface Exception
 */
export interface Exception {
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exception
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotAuthorizedException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Reaction
 */
export interface Reaction {
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'id'?: string;
    /**
     * 
     * @type {ReactionType}
     * @memberof Reaction
     */
    'likeReaction'?: ReactionType;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'last_update_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'subject_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Reaction
     */
    'vision'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Reaction
     */
    'StarsNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'comment'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReactionType = {
    Like: 'LIKE',
    Dislike: 'DISLIKE'
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];


/**
 * 
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Client: 'CLIENT',
    Manager: 'MANAGER'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @enum {string}
 */

export const Sex = {
    M: 'M',
    F: 'F',
    Other: 'OTHER'
} as const;

export type Sex = typeof Sex[keyof typeof Sex];


/**
 * 
 * @export
 * @interface SignUp
 */
export interface SignUp {
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUp
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof SignUp
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof SignUp
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof SignUp
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TooManyRequestsException
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'photo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_banner_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'entrance_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    'status'?: UserStatus;
    /**
     * 
     * @type {Sex}
     * @memberof User
     */
    'sex'?: Sex;
    /**
     * 
     * @type {Role}
     * @memberof User
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface UserPicture
 */
export interface UserPicture {
    /**
     * 
     * @type {string}
     * @memberof UserPicture
     */
    'user_id'?: string;
    /**
     * 
     * @type {UserPictureType}
     * @memberof UserPicture
     */
    'type'?: UserPictureType;
    /**
     * 
     * @type {string}
     * @memberof UserPicture
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserPictureType = {
    Banner: 'BANNER',
    Profile: 'PROFILE'
} as const;

export type UserPictureType = typeof UserPictureType[keyof typeof UserPictureType];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Enabled: 'ENABLED',
    Banished: 'BANISHED'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 
 * @export
 * @interface Whoami
 */
export interface Whoami {
    /**
     * 
     * @type {User}
     * @memberof Whoami
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Whoami
     */
    'bearer'?: string;
}
/**
 * 
 * @export
 * @interface Xxxxxx
 */
export interface Xxxxxx {
    /**
     * 
     * @type {string}
     * @memberof Xxxxxx
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Xxxxxx
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Xxxxxx
     */
    'updated_at'?: string;
    /**
     * 
     * @type {User}
     * @memberof Xxxxxx
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface Yyyyyy
 */
export interface Yyyyyy {
    /**
     * 
     * @type {string}
     * @memberof Yyyyyy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Yyyyyy
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Yyyyyy
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Xxxxxx}
     * @memberof Yyyyyy
     */
    'xxxxxx'?: Xxxxxx;
    /**
     * 
     * @type {Zzzzzz}
     * @memberof Yyyyyy
     */
    'zzzzzz'?: Zzzzzz;
}
/**
 * 
 * @export
 * @interface Zzzzzz
 */
export interface Zzzzzz {
    /**
     * 
     * @type {string}
     * @memberof Zzzzzz
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Zzzzzz
     */
    'creation_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Zzzzzz
     */
    'updated_at'?: string;
}

/**
 * ChatbotApi - axios parameter creator
 * @export
 */
export const ChatbotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotInformation: async (id: string, prompt: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChatbotInformation', 'id', id)
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('getChatbotInformation', 'prompt', prompt)
            const localVarPath = `/users/{id}/chat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (prompt !== undefined) {
                localVarQueryParameter['prompt'] = prompt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotApi - functional programming interface
 * @export
 */
export const ChatbotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbotInformation(id: string, prompt: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbotInformation(id, prompt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.getChatbotInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotApi - factory interface
 * @export
 */
export const ChatbotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotApiFp(configuration)
    return {
        /**
         * 
         * @summary Obtain information from the chatbot.
         * @param {string} id 
         * @param {string} prompt The question to ask the chatbot about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotInformation(id: string, prompt: string, options?: any): AxiosPromise<Array<ChatResponse>> {
            return localVarFp.getChatbotInformation(id, prompt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatbotApi - object-oriented interface
 * @export
 * @class ChatbotApi
 * @extends {BaseAPI}
 */
export class ChatbotApi extends BaseAPI {
    /**
     * 
     * @summary Obtain information from the chatbot.
     * @param {string} id 
     * @param {string} prompt The question to ask the chatbot about.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getChatbotInformation(id: string, prompt: string, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getChatbotInformation(id, prompt, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary ping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (authenticationPayload: AuthenticationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationPayload' is not null or undefined
            assertParamExists('signIn', 'authenticationPayload', authenticationPayload)
            const localVarPath = `/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUp: SignUp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUp' is not null or undefined
            assertParamExists('signUp', 'signUp', signUp)
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(authenticationPayload: AuthenticationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(authenticationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUp: SignUp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.whoami']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * 
         * @summary Login user.
         * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(authenticationPayload: AuthenticationPayload, options?: any): AxiosPromise<Whoami> {
            return localVarFp.signIn(authenticationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up user
         * @param {SignUp} signUp Sign up payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUp: SignUp, options?: any): AxiosPromise<Whoami> {
            return localVarFp.signUp(signUp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tells you who you are.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<Whoami> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary Login user.
     * @param {AuthenticationPayload} authenticationPayload Login payload. set \&#39;user_id\&#39; to null when authenticating with email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public signIn(authenticationPayload: AuthenticationPayload, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).signIn(authenticationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up user
     * @param {SignUp} signUp Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public signUp(signUp: SignUp, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).signUp(signUp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tells you who you are.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public whoami(options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateUserById: async (id: string, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crupdateUserById', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('crupdateUserById', 'user', user)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPicture: async (uid: string, type: UserPictureType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserPicture', 'uid', uid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getUserPicture', 'type', type)
            const localVarPath = `/users/{uid}/pictures`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page: number, pageSize: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getUsers', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getUsers', 'pageSize', pageSize)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPicture: async (uid: string, type: UserPictureType, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('putUserPicture', 'uid', uid)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('putUserPicture', 'type', type)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putUserPicture', 'body', body)
            const localVarPath = `/users/{uid}/pictures`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateUserById(id: string, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateUserById(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.crupdateUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPicture(uid: string, type: UserPictureType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPicture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPicture(uid, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page: number, pageSize: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(page, pageSize, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserPicture(uid: string, type: UserPictureType, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPicture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserPicture(uid, type, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.putUserPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Crupdate user by identifier.
         * @param {string} id 
         * @param {User} user User to crupdate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateUserById(id: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.crupdateUserById(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by identifier.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPicture(uid: string, type: UserPictureType, options?: any): AxiosPromise<UserPicture> {
            return localVarFp.getUserPicture(uid, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [name] Filter user by first name or lastname or username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page: number, pageSize: number, name?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(page, pageSize, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit user picture of the type profile banner or profile picture
         * @param {string} uid 
         * @param {UserPictureType} type 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPicture(uid: string, type: UserPictureType, body: File, options?: any): AxiosPromise<UserPicture> {
            return localVarFp.putUserPicture(uid, type, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Crupdate user by identifier.
     * @param {string} id 
     * @param {User} user User to crupdate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public crupdateUserById(id: string, user: User, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).crupdateUserById(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by identifier.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user picture of the type profile banner or profile picture
     * @param {string} uid 
     * @param {UserPictureType} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserPicture(uid: string, type: UserPictureType, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserPicture(uid, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users.
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [name] Filter user by first name or lastname or username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(page: number, pageSize: number, name?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(page, pageSize, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit user picture of the type profile banner or profile picture
     * @param {string} uid 
     * @param {UserPictureType} type 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserPicture(uid: string, type: UserPictureType, body: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserPicture(uid, type, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * XxxxxxingApi - axios parameter creator
 * @export
 */
export const XxxxxxingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reacte an xxxxxxs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionXxxxxxs: async (uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('crupdateReactionXxxxxxs', 'uid', uid)
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('crupdateReactionXxxxxxs', 'xid', xid)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('crupdateReactionXxxxxxs', 'reaction', reaction)
            const localVarPath = `/users/{uid}/xxxxxxs/{xid}/react`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crupdate xxxxxx by identifier.
         * @param {string} pid 
         * @param {Xxxxxx} xxxxxx Xxxxxx to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateXxxxxxById: async (pid: string, xxxxxx: Xxxxxx, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateXxxxxxById', 'pid', pid)
            // verify required parameter 'xxxxxx' is not null or undefined
            assertParamExists('crupdateXxxxxxById', 'xxxxxx', xxxxxx)
            const localVarPath = `/xxxxxxs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xxxxxx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteXxxxxxById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('deleteXxxxxxById', 'pid', pid)
            const localVarPath = `/xxxxxxs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all ReactionXxxxxxs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionXxxxxxs: async (xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getReactionXxxxxxs', 'xid', xid)
            const localVarPath = `/xxxxxxs/{xid}/react`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (haveLikeReaction !== undefined) {
                localVarQueryParameter['have_like_reaction'] = haveLikeReaction;
            }

            if (haveVision !== undefined) {
                localVarQueryParameter['have_vision'] = haveVision;
            }

            if (haveStarsNumber !== undefined) {
                localVarQueryParameter['have_stars_number'] = haveStarsNumber;
            }

            if (haveComment !== undefined) {
                localVarQueryParameter['have_comment'] = haveComment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXxxxxxById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getXxxxxxById', 'pid', pid)
            const localVarPath = `/xxxxxxs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all xxxxxxs.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXxxxxxs: async (page?: number, pageSize?: number, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/xxxxxxs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * XxxxxxingApi - functional programming interface
 * @export
 */
export const XxxxxxingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = XxxxxxingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Reacte an xxxxxxs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateReactionXxxxxxs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateReactionXxxxxxs(uid, xid, reaction, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.crupdateReactionXxxxxxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crupdate xxxxxx by identifier.
         * @param {string} pid 
         * @param {Xxxxxx} xxxxxx Xxxxxx to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateXxxxxxById(pid: string, xxxxxx: Xxxxxx, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Xxxxxx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateXxxxxxById(pid, xxxxxx, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.crupdateXxxxxxById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteXxxxxxById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Xxxxxx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteXxxxxxById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.deleteXxxxxxById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all ReactionXxxxxxs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReactionXxxxxxs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReactionXxxxxxs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.getReactionXxxxxxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getXxxxxxById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Xxxxxx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getXxxxxxById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.getXxxxxxById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all xxxxxxs.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getXxxxxxs(page?: number, pageSize?: number, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Xxxxxx>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getXxxxxxs(page, pageSize, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['XxxxxxingApi.getXxxxxxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * XxxxxxingApi - factory interface
 * @export
 */
export const XxxxxxingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = XxxxxxingApiFp(configuration)
    return {
        /**
         * 
         * @summary Reacte an xxxxxxs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionXxxxxxs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: any): AxiosPromise<Reaction> {
            return localVarFp.crupdateReactionXxxxxxs(uid, xid, reaction, isSuggest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crupdate xxxxxx by identifier.
         * @param {string} pid 
         * @param {Xxxxxx} xxxxxx Xxxxxx to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateXxxxxxById(pid: string, xxxxxx: Xxxxxx, options?: any): AxiosPromise<Xxxxxx> {
            return localVarFp.crupdateXxxxxxById(pid, xxxxxx, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteXxxxxxById(pid: string, options?: any): AxiosPromise<Xxxxxx> {
            return localVarFp.deleteXxxxxxById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all ReactionXxxxxxs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionXxxxxxs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.getReactionXxxxxxs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get xxxxxx by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXxxxxxById(pid: string, options?: any): AxiosPromise<Xxxxxx> {
            return localVarFp.getXxxxxxById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all xxxxxxs.
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXxxxxxs(page?: number, pageSize?: number, isSuggest?: boolean, options?: any): AxiosPromise<Array<Xxxxxx>> {
            return localVarFp.getXxxxxxs(page, pageSize, isSuggest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * XxxxxxingApi - object-oriented interface
 * @export
 * @class XxxxxxingApi
 * @extends {BaseAPI}
 */
export class XxxxxxingApi extends BaseAPI {
    /**
     * 
     * @summary Reacte an xxxxxxs.
     * @param {string} uid 
     * @param {string} xid 
     * @param {Reaction} reaction Reaction to crupdate
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public crupdateReactionXxxxxxs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).crupdateReactionXxxxxxs(uid, xid, reaction, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crupdate xxxxxx by identifier.
     * @param {string} pid 
     * @param {Xxxxxx} xxxxxx Xxxxxx to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public crupdateXxxxxxById(pid: string, xxxxxx: Xxxxxx, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).crupdateXxxxxxById(pid, xxxxxx, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete xxxxxx by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public deleteXxxxxxById(pid: string, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).deleteXxxxxxById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all ReactionXxxxxxs.
     * @param {string} xid 
     * @param {string} [uid] 
     * @param {boolean} [haveLikeReaction] 
     * @param {boolean} [haveVision] 
     * @param {boolean} [haveStarsNumber] 
     * @param {boolean} [haveComment] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public getReactionXxxxxxs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).getReactionXxxxxxs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get xxxxxx by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public getXxxxxxById(pid: string, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).getXxxxxxById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all xxxxxxs.
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XxxxxxingApi
     */
    public getXxxxxxs(page?: number, pageSize?: number, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return XxxxxxingApiFp(this.configuration).getXxxxxxs(page, pageSize, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * YyyyyyingApi - axios parameter creator
 * @export
 */
export const YyyyyyingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reacte an yyyyyys.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionYyyyyys: async (uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('crupdateReactionYyyyyys', 'uid', uid)
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('crupdateReactionYyyyyys', 'xid', xid)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('crupdateReactionYyyyyys', 'reaction', reaction)
            const localVarPath = `/users/{uid}/yyyyyys/{xid}/react`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crupdate yyyyyy by identifier.
         * @param {string} pid 
         * @param {Yyyyyy} yyyyyy Yyyyyy to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateYyyyyyById: async (pid: string, yyyyyy: Yyyyyy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateYyyyyyById', 'pid', pid)
            // verify required parameter 'yyyyyy' is not null or undefined
            assertParamExists('crupdateYyyyyyById', 'yyyyyy', yyyyyy)
            const localVarPath = `/yyyyyys/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(yyyyyy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteYyyyyyById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('deleteYyyyyyById', 'pid', pid)
            const localVarPath = `/yyyyyys/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all ReactionYyyyyys.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionYyyyyys: async (xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getReactionYyyyyys', 'xid', xid)
            const localVarPath = `/yyyyyys/{xid}/react`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (haveLikeReaction !== undefined) {
                localVarQueryParameter['have_like_reaction'] = haveLikeReaction;
            }

            if (haveVision !== undefined) {
                localVarQueryParameter['have_vision'] = haveVision;
            }

            if (haveStarsNumber !== undefined) {
                localVarQueryParameter['have_stars_number'] = haveStarsNumber;
            }

            if (haveComment !== undefined) {
                localVarQueryParameter['have_comment'] = haveComment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyyById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getYyyyyyById', 'pid', pid)
            const localVarPath = `/yyyyyys/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pdf of a specific yyyyyy.
         * @param {string} id 
         * @param {string} yyyyyyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyyPdf: async (id: string, yyyyyyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getYyyyyyPdf', 'id', id)
            // verify required parameter 'yyyyyyId' is not null or undefined
            assertParamExists('getYyyyyyPdf', 'yyyyyyId', yyyyyyId)
            const localVarPath = `/Users/{id}/yyyyyy/{yyyyyy_id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"yyyyyy_id"}}`, encodeURIComponent(String(yyyyyyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all yyyyyys.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [categories] yyyyyy
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyys: async (page: number, pageSize: number, categories?: string, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getYyyyyys', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getYyyyyys', 'pageSize', pageSize)
            const localVarPath = `/yyyyyys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (categories !== undefined) {
                localVarQueryParameter['categories'] = categories;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YyyyyyingApi - functional programming interface
 * @export
 */
export const YyyyyyingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = YyyyyyingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Reacte an yyyyyys.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateReactionYyyyyys(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateReactionYyyyyys(uid, xid, reaction, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.crupdateReactionYyyyyys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crupdate yyyyyy by identifier.
         * @param {string} pid 
         * @param {Yyyyyy} yyyyyy Yyyyyy to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateYyyyyyById(pid: string, yyyyyy: Yyyyyy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Yyyyyy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateYyyyyyById(pid, yyyyyy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.crupdateYyyyyyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteYyyyyyById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Yyyyyy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteYyyyyyById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.deleteYyyyyyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all ReactionYyyyyys.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReactionYyyyyys(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReactionYyyyyys(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.getReactionYyyyyys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYyyyyyById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Yyyyyy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYyyyyyById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.getYyyyyyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pdf of a specific yyyyyy.
         * @param {string} id 
         * @param {string} yyyyyyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYyyyyyPdf(id: string, yyyyyyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYyyyyyPdf(id, yyyyyyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.getYyyyyyPdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all yyyyyys.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [categories] yyyyyy
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYyyyyys(page: number, pageSize: number, categories?: string, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Yyyyyy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYyyyyys(page, pageSize, categories, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YyyyyyingApi.getYyyyyys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * YyyyyyingApi - factory interface
 * @export
 */
export const YyyyyyingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = YyyyyyingApiFp(configuration)
    return {
        /**
         * 
         * @summary Reacte an yyyyyys.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionYyyyyys(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: any): AxiosPromise<Reaction> {
            return localVarFp.crupdateReactionYyyyyys(uid, xid, reaction, isSuggest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crupdate yyyyyy by identifier.
         * @param {string} pid 
         * @param {Yyyyyy} yyyyyy Yyyyyy to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateYyyyyyById(pid: string, yyyyyy: Yyyyyy, options?: any): AxiosPromise<Yyyyyy> {
            return localVarFp.crupdateYyyyyyById(pid, yyyyyy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteYyyyyyById(pid: string, options?: any): AxiosPromise<Yyyyyy> {
            return localVarFp.deleteYyyyyyById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all ReactionYyyyyys.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionYyyyyys(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.getReactionYyyyyys(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get yyyyyy by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyyById(pid: string, options?: any): AxiosPromise<Yyyyyy> {
            return localVarFp.getYyyyyyById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pdf of a specific yyyyyy.
         * @param {string} id 
         * @param {string} yyyyyyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyyPdf(id: string, yyyyyyId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getYyyyyyPdf(id, yyyyyyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all yyyyyys.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {string} [categories] yyyyyy
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYyyyyys(page: number, pageSize: number, categories?: string, isSuggest?: boolean, options?: any): AxiosPromise<Array<Yyyyyy>> {
            return localVarFp.getYyyyyys(page, pageSize, categories, isSuggest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * YyyyyyingApi - object-oriented interface
 * @export
 * @class YyyyyyingApi
 * @extends {BaseAPI}
 */
export class YyyyyyingApi extends BaseAPI {
    /**
     * 
     * @summary Reacte an yyyyyys.
     * @param {string} uid 
     * @param {string} xid 
     * @param {Reaction} reaction Reaction to crupdate
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public crupdateReactionYyyyyys(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).crupdateReactionYyyyyys(uid, xid, reaction, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crupdate yyyyyy by identifier.
     * @param {string} pid 
     * @param {Yyyyyy} yyyyyy Yyyyyy to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public crupdateYyyyyyById(pid: string, yyyyyy: Yyyyyy, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).crupdateYyyyyyById(pid, yyyyyy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete yyyyyy by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public deleteYyyyyyById(pid: string, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).deleteYyyyyyById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all ReactionYyyyyys.
     * @param {string} xid 
     * @param {string} [uid] 
     * @param {boolean} [haveLikeReaction] 
     * @param {boolean} [haveVision] 
     * @param {boolean} [haveStarsNumber] 
     * @param {boolean} [haveComment] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public getReactionYyyyyys(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).getReactionYyyyyys(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get yyyyyy by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public getYyyyyyById(pid: string, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).getYyyyyyById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pdf of a specific yyyyyy.
     * @param {string} id 
     * @param {string} yyyyyyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public getYyyyyyPdf(id: string, yyyyyyId: string, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).getYyyyyyPdf(id, yyyyyyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all yyyyyys.
     * @param {number} page 
     * @param {number} pageSize 
     * @param {string} [categories] yyyyyy
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YyyyyyingApi
     */
    public getYyyyyys(page: number, pageSize: number, categories?: string, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return YyyyyyingApiFp(this.configuration).getYyyyyys(page, pageSize, categories, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ZzzzzzingApi - axios parameter creator
 * @export
 */
export const ZzzzzzingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reacte an zzzzzzs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionZzzzzzs: async (uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('crupdateReactionZzzzzzs', 'uid', uid)
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('crupdateReactionZzzzzzs', 'xid', xid)
            // verify required parameter 'reaction' is not null or undefined
            assertParamExists('crupdateReactionZzzzzzs', 'reaction', reaction)
            const localVarPath = `/users/{uid}/zzzzzzs/{xid}/react`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Crupdate zzzzzz by identifier.
         * @param {string} pid 
         * @param {Zzzzzz} zzzzzz Zzzzzz to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateZzzzzzById: async (pid: string, zzzzzz: Zzzzzz, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('crupdateZzzzzzById', 'pid', pid)
            // verify required parameter 'zzzzzz' is not null or undefined
            assertParamExists('crupdateZzzzzzById', 'zzzzzz', zzzzzz)
            const localVarPath = `/zzzzzzs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(zzzzzz, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZzzzzzById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('deleteZzzzzzById', 'pid', pid)
            const localVarPath = `/zzzzzzs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all ReactionZzzzzzs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionZzzzzzs: async (xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xid' is not null or undefined
            assertParamExists('getReactionZzzzzzs', 'xid', xid)
            const localVarPath = `/zzzzzzs/{xid}/react`
                .replace(`{${"xid"}}`, encodeURIComponent(String(xid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (haveLikeReaction !== undefined) {
                localVarQueryParameter['have_like_reaction'] = haveLikeReaction;
            }

            if (haveVision !== undefined) {
                localVarQueryParameter['have_vision'] = haveVision;
            }

            if (haveStarsNumber !== undefined) {
                localVarQueryParameter['have_stars_number'] = haveStarsNumber;
            }

            if (haveComment !== undefined) {
                localVarQueryParameter['have_comment'] = haveComment;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZzzzzzById: async (pid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('getZzzzzzById', 'pid', pid)
            const localVarPath = `/zzzzzzs/{pid}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all zzzzzzs.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZzzzzzs: async (page: number, pageSize: number, isSuggest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getZzzzzzs', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getZzzzzzs', 'pageSize', pageSize)
            const localVarPath = `/zzzzzzs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (isSuggest !== undefined) {
                localVarQueryParameter['isSuggest'] = isSuggest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZzzzzzingApi - functional programming interface
 * @export
 */
export const ZzzzzzingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ZzzzzzingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Reacte an zzzzzzs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateReactionZzzzzzs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateReactionZzzzzzs(uid, xid, reaction, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.crupdateReactionZzzzzzs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Crupdate zzzzzz by identifier.
         * @param {string} pid 
         * @param {Zzzzzz} zzzzzz Zzzzzz to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateZzzzzzById(pid: string, zzzzzz: Zzzzzz, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zzzzzz>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateZzzzzzById(pid, zzzzzz, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.crupdateZzzzzzById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZzzzzzById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zzzzzz>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteZzzzzzById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.deleteZzzzzzById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all ReactionZzzzzzs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReactionZzzzzzs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReactionZzzzzzs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.getReactionZzzzzzs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZzzzzzById(pid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zzzzzz>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZzzzzzById(pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.getZzzzzzById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all zzzzzzs.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZzzzzzs(page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zzzzzz>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZzzzzzs(page, pageSize, isSuggest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZzzzzzingApi.getZzzzzzs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ZzzzzzingApi - factory interface
 * @export
 */
export const ZzzzzzingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZzzzzzingApiFp(configuration)
    return {
        /**
         * 
         * @summary Reacte an zzzzzzs.
         * @param {string} uid 
         * @param {string} xid 
         * @param {Reaction} reaction Reaction to crupdate
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateReactionZzzzzzs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: any): AxiosPromise<Reaction> {
            return localVarFp.crupdateReactionZzzzzzs(uid, xid, reaction, isSuggest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Crupdate zzzzzz by identifier.
         * @param {string} pid 
         * @param {Zzzzzz} zzzzzz Zzzzzz to crupdate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateZzzzzzById(pid: string, zzzzzz: Zzzzzz, options?: any): AxiosPromise<Zzzzzz> {
            return localVarFp.crupdateZzzzzzById(pid, zzzzzz, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZzzzzzById(pid: string, options?: any): AxiosPromise<Zzzzzz> {
            return localVarFp.deleteZzzzzzById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all ReactionZzzzzzs.
         * @param {string} xid 
         * @param {string} [uid] 
         * @param {boolean} [haveLikeReaction] 
         * @param {boolean} [haveVision] 
         * @param {boolean} [haveStarsNumber] 
         * @param {boolean} [haveComment] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReactionZzzzzzs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.getReactionZzzzzzs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get zzzzzz by identifier.
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZzzzzzById(pid: string, options?: any): AxiosPromise<Zzzzzz> {
            return localVarFp.getZzzzzzById(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all zzzzzzs.
         * @param {number} page 
         * @param {number} pageSize 
         * @param {boolean} [isSuggest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZzzzzzs(page: number, pageSize: number, isSuggest?: boolean, options?: any): AxiosPromise<Array<Zzzzzz>> {
            return localVarFp.getZzzzzzs(page, pageSize, isSuggest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZzzzzzingApi - object-oriented interface
 * @export
 * @class ZzzzzzingApi
 * @extends {BaseAPI}
 */
export class ZzzzzzingApi extends BaseAPI {
    /**
     * 
     * @summary Reacte an zzzzzzs.
     * @param {string} uid 
     * @param {string} xid 
     * @param {Reaction} reaction Reaction to crupdate
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public crupdateReactionZzzzzzs(uid: string, xid: string, reaction: Reaction, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).crupdateReactionZzzzzzs(uid, xid, reaction, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Crupdate zzzzzz by identifier.
     * @param {string} pid 
     * @param {Zzzzzz} zzzzzz Zzzzzz to crupdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public crupdateZzzzzzById(pid: string, zzzzzz: Zzzzzz, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).crupdateZzzzzzById(pid, zzzzzz, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete zzzzzz by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public deleteZzzzzzById(pid: string, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).deleteZzzzzzById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all ReactionZzzzzzs.
     * @param {string} xid 
     * @param {string} [uid] 
     * @param {boolean} [haveLikeReaction] 
     * @param {boolean} [haveVision] 
     * @param {boolean} [haveStarsNumber] 
     * @param {boolean} [haveComment] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public getReactionZzzzzzs(xid: string, uid?: string, haveLikeReaction?: boolean, haveVision?: boolean, haveStarsNumber?: boolean, haveComment?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).getReactionZzzzzzs(xid, uid, haveLikeReaction, haveVision, haveStarsNumber, haveComment, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get zzzzzz by identifier.
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public getZzzzzzById(pid: string, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).getZzzzzzById(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all zzzzzzs.
     * @param {number} page 
     * @param {number} pageSize 
     * @param {boolean} [isSuggest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZzzzzzingApi
     */
    public getZzzzzzs(page: number, pageSize: number, isSuggest?: boolean, options?: RawAxiosRequestConfig) {
        return ZzzzzzingApiFp(this.configuration).getZzzzzzs(page, pageSize, isSuggest, options).then((request) => request(this.axios, this.basePath));
    }
}



